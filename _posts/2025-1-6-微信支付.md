---
layout: post
title: 关于对接JSAPI微信支付
date: 2024-12-27
author: ni
catalog: true
tags:
  - SDK
  - 微信支付
---

## 前言

**在对接JSAPI时遇到点问题，在此记录下**

## 流程

**1. 创建订单，并进行预下单，将时间戳，预支付id等信息保存到订单信息**

**2. 前端调起支付时，根据订单Id，返回支付所需参数，由前端拉起支付**

**3. 支付完后，编写回调接口，修改订单状态**

**4. 编写退款接口，进行退款**

**5. 编写退款回调接口，退款后进行更新订单**

## 预支付

**添加超时时间一定要将格式修改为 `yyyy-MM-dd'T'HH:mm:ssXXX` 并注意时区**

```java
private JsPayResultData wxPay(Integer totalAmountInCents, OrderInfo orderInfo, String openId) {
        com.wechat.pay.java.service.payments.jsapi.model.PrepayRequest prepayRequest = new com.wechat.pay.java.service.payments.jsapi.model.PrepayRequest();
        prepayRequest.setAppid(weChatConfig.getAppId());
        prepayRequest.setMchid(weChatConfig.getMerchantId());
        prepayRequest.setDescription(orderInfo.getOrderName());  // 订单描述
        prepayRequest.setNotifyUrl(weChatConfig.getNotifyUrl()); // 回调地址
        prepayRequest.setOutTradeNo(orderInfo.getOrderSn()); // 订单号

        com.wechat.pay.java.service.payments.jsapi.model.Amount amount = new com.wechat.pay.java.service.payments.jsapi.model.Amount();
        amount.setTotal(totalAmountInCents);
        amount.setCurrency("CNY");
        prepayRequest.setAmount(amount);
        Payer payer = new Payer();
        // TODO 开发完公众号登录，填充openid
        if(openId == null){
            throw new ServiceException("登录信息过期，请重新登录", 401);
        }
        payer.setOpenid(openId);
        prepayRequest.setPayer(payer);

        // 添加超时时间
        // 当前时间加5分钟
        prepayRequest.setTimeExpire(LocalDateTime.now()
                .plusMinutes(5)
                .atZone(ZoneId.systemDefault())  // 或者明确指定 ZoneId.of("Asia/Shanghai")
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssXXX")));
        // 调用下单方法，得到应答
        try {
            com.wechat.pay.java.service.payments.jsapi.model.PrepayResponse prepay = jsapiService.prepay(prepayRequest);
            //组合jsapi下单参数
            JsPayResultData jsPayResultData = new JsPayResultData();
            jsPayResultData.setAppId(weChatConfig.getAppId());
            jsPayResultData.setTimeStamp(String.valueOf(WeChatUtil.getCurrentTimestamp()));
            jsPayResultData.setNonceStr(WeChatUtil.generateNonceStr());
            jsPayResultData.setPrepayId("prepay_id=" + prepay.getPrepayId());
            String privateKey = null;
            try (InputStream inputStream = getClass().getResourceAsStream(weChatConfig.getPrivateKeyPath())){
                privateKey = IOUtil.toString(inputStream);
            } catch (IOException e) {
                Log.error("IO异常， {}", e);
            }
            jsPayResultData.setPaySign(
                    WeChatUtil.getSign(
                    Stream.of(jsPayResultData.getAppId(), jsPayResultData.getTimeStamp(), jsPayResultData.getNonceStr(), jsPayResultData.getPrepayId()).collect(Collectors.joining("\n", "", "\n")),
                    privateKey,
                    weChatConfig.getMerchantSerialNumber()
                    )
            );
            //预支付成功，创建预支付订单

            return jsPayResultData;
        } catch (HttpException e) { // 发送HTTP请求失败
            log.error("发送HTTP请求失败: {}", e.getHttpRequest());
        } catch (ServiceException e) { // 服务返回状态小于200或大于等于300，例如500
            log.error("服务返回状态异常: {}", e.getMessage());
        } catch (MalformedMessageException e) { // 服务返回成功，返回体类型不合法，或者解析返回体失败
            log.error("返回体类型不合法: {}", e.getMessage());
        } catch (Exception e) {
            log.error("预下单异常: {}", e.getMessage());
        }
        return null;
    }
```

## 调起支付



```java
String privateKey = null;
try (InputStream inputStream = getClass().getResourceAsStream(weChatConfig.getPrivateKeyPath())){
    privateKey = IOUtil.toString(inputStream);
} catch (IOException e) {
    Log.error("IO异常， {}", e);
}

String sign = WeChatUtil.getSign(
        Stream.of(orderInfo.getAppId(), orderInfo.getTimeStamp(), orderInfo.getNonceStr(), orderInfo.getPrepayId()).collect(Collectors.joining("\n", "", "\n")),
        privateKey,
        weChatConfig.getMerchantSerialNumber()
);
```

#### <font color="red">踩坑</font>

**在微信的SDK中提供了`PemUtil`工具类，里面有两个方法**

- **`loadPrivateKeyFromString`：加载秘钥通过String字符串的方式**
- **`loadPrivateKeyFromPath`：加载通过路径的方式**

**开始对接时把秘钥放在Resource下通过ClassLoad.getResource，本地测试可以通过**

**部署上线后，打成了jar包获取不到。如果把文件上传到服务器中并使用绝对路径就可以使用**

**所以推荐使用第一种`loadPrivateKeyFromString`**

## 支付回调

```java
    public static RequestParam handleNodifyRequestParam(HttpServletRequest request) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(request.getInputStream(), StandardCharsets.UTF_8));
        String line ;
        StringBuilder sb = new StringBuilder();
        while ((line = br.readLine()) != null){
            sb.append(line);
        }
        br.close();
        String body = sb.toString();
        // 请求头 Wechatpay-Signature
        String signature = request.getHeader("Wechatpay-Signature");
        // 请求头 Wechatpay-nonce
        String nonce = request.getHeader("Wechatpay-Nonce");
        // 请求头 Wechatpay-Timestamp
        String timestamp = request.getHeader("Wechatpay-Timestamp");
        // 微信支付证书序列号
        String serial = request.getHeader("Wechatpay-Serial");


        // 构造 RequestParam
        return new RequestParam.Builder()
                .body(body)
                .nonce(nonce)
                .serialNumber(serial)
                .signature(signature)
                .timestamp(timestamp)
                .build();

    }


}
```

#### <font color="red">踩坑</font>

**在回调时通过请求头获取到参数，获取参数是加密状态的，需要通过验签进行解密。**

**根据微信文档和SDK的步骤进行操作，发现验签失败**

**后续根据请求参数发现有乱码，进行UTF_8进行获取解决**





